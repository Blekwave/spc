spojbr_duende.cpp
Autor: Jonatas
Usuário:
Solução:

spojbr_irevir.cpp
Autor: Victor
Usuário: Blek
Solução:

spojbr_mesa.cpp
Autor: Victor
Usuário: Blek
Solução:

spojbr_natureza.cpp
Autor: Renato
Usuário: renatoutsch
Solução:
Esse problema foi resolvido usando um map de strings (nome do animal) para
um set de outras strings (animais aos quais o animal é ligado na cadeia
alimentar). O nome dos animais iniciais não é necessário, e portanto essa parte
da entrada é ignorada. Após isso, para cada aresta do grafo lida é adicionada
uma entrada no gravo em ambas as direções, de modo a criar um grafo não
direcionado.
Para a contagem da cadeia alimentar, uma busca em profundidade simples foi
usada. Essa busca removia do grafo cada nó por onde passava, enquanto aumentava
a contagem de nós. Desse modo, todo o subgrafo era removido do grafo inicial,
gerando a contagem de membros da cadeia. Essa operação era repetida até o grafo
ficar vazio e, finalmente, a maior das cadeias era impressa.

spojbr_orkut.cpp
Autor: Lucas
Usuário:
Solução:
Para resolver esse problema, recebemos as exigências de
cada amigo. Armazenamos o grafo de exigências em uma
lista de adjacências. Realizamos a ordenação topológica
da seguinte forma: Passamos por todos os vértices e
armazenamos aqueles nos quais não incidem arestas em uma
fila. Ordenamos essa fila por ordem de entrada, e pegamos
o primeiro elemento dessa fila, colocando-o na lista já
ordenada. Retiramos esse elemento da lista de exigências
dos outros amigos, e repetimos o processo até que não hajam
mais elementos sem arestas incidentes. Caso a lista de resultados
tenha todos os amigos informados, exibimos essa lista na
saída. Do contrário, exibimos a palavra "impossivel".


spojbr_pedagio.cpp
Autor: Jonatas
Usuário:
Solução:


uri_1469.cpp
Autor: Renato
Usuário: 29916 (renatoutsch@gmail.com)
Solução:
Esse problema foi resolvido adicionando as arestas dos nós de maneira invertida:
a cada entrada de par de trabalhador e chefe, uma aresta era adicionada no sentido
de que o trabalhador possui tal chefe. Após isso, ao fazer um swap apenas a idade
é trocada, e um vetor de nomes é usado para manter referência de qual nome se refere
a qual trabalhador.
Após tudo isso, apenas um algoritmo de BFS (ou DFS iterativo, o recursivo dá
time limit) simples encontra o chefe de menor idade.

UVa_11060.cpp
Autor: Jonatas
Usuário:
Solução:


